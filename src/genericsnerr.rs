// GENERIC TYPES AND ERROR HANDLING

// generic struct
struct Gstruct<T> {
    item: T,
}

// None is like NULL but isnt NULL
// This pattern of providing a None alternative representation for one or many alternate values is so common
// in Rust because of its lack of a null value. Generic types help solve this challenge.
#[allow(dead_code)]
enum Item {
    Inventory(String),
    // None represents the absence of an item
    None,
}

#[allow(dead_code)]
// None struct
struct Nstruct {
    item: Item,
}

struct BagOfHolding<T> {
    // Our parameter type T can be handed to others
    item: Option<T>,
}

pub fn run() {
    // Note: by using generic types here, we create compile-time created types.
    // Turbofish ::<T> lets us be explicit.

    let gi32 = Gstruct::<i32> { item: 42 };
    println!("{}", gi32.item);

    // Rust can infer types for generics too!
    let gi32 = Gstruct { item: 43 };
    println!("{}", gi32.item);

    let gstruct_in_gstruct = Gstruct {
        item: Gstruct { item: "boom!" },
    };
    println!("{}", gstruct_in_gstruct.item.item);

    // Note: A bag for i32, holding nothing! We have to specify the type
    // because otherwise Rust would not know what type of bag it is.
    let i32_bag = BagOfHolding::<i32> { item: None };

    if i32_bag.item.is_none() {
        println!("there's nothing in the bag!")
    } else {
        println!("there's something in the bag!")
    }

    let i32_bag = BagOfHolding::<i32> { item: Some(42) };

    if i32_bag.item.is_some() {
        println!("there's something in the bag!")
    } else {
        println!("there's nothing in the bag!")
    }

    // match lets us deconstruct Option elegantly and ensure we handle all cases!
    match i32_bag.item {
        Some(v) => println!("found {} in bag!", v),
        None => println!("found nothing"),
    }

    let result = do_something_that_might_fail(12);
    // match lets us deconstruct Result elegantly and ensure we handle all cases!
    // s, b are created from what you give Ok and Err
    match result {
        Ok(s) => println!("found {}", s),
        Err(b) => println!("Error: {}", b),
    }

    //if error happened then print the error and panic
    //let unwrap_example = do_something_that_might_fail(12).unwrap();

    // These two pieces of code are equivalent:
    // do_something_that_might_fail(12).unwrap()
    // match do_something_that_might_fail(12){
    // Some(v) => v,
    // None => panic!("some error message generated by Rust!"),
    //}

    // same as above and print where and what happened what you expect
    //let expect_example = do_something_that_might_fail(12).expect("bro");

    //Be a good rustacean and properly use match when you can!
}

// Rust has a built in generic enum called Result that allows us to return a value that has the possibility of failing.
// It is the idiomatic way in which the language does error handling.
//
// Note that our generics type has multiple parameterized types separated by a comma.
// f32 is the ok type return and String is the error return
// if it worked return the ok result if didnt retrun error result
fn do_something_that_might_fail(i: i32) -> Result<f32, String> {
    if i == 42 {
        Ok(13.0)
    } else {
        Err(String::from("this is not the right number"))
    }
}
